# -*- coding: utf-8 -*-
"""Copia de Final_FInal_FTYOLO11_Dt2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14f6qcg2PfAENxLGN7W1dr-lw8rN7HAuF

Cargar Datos Drive
"""

import os
# Use drive._mount() instead of drive.mount()
from google.colab import drive

drive.mount('/content/drive')

!unzip "/content/drive/MyDrive/ProyectoFin/Dst2_Segmentacion.zip" -d /content/drive/MyDrive/ProyectoFin/Dst2_Segmentacion

import yaml

data = {
    'path': '/content/drive/MyDrive/ProyectoFin/Dst2_Segmentacion/Dst2_Segmentacion',
    'train': 'images/train',
    'val': 'images/val',
    'test': 'images/test',
    'names': {
  0: 'suelo',
  1: 'vegetacion',
  2: 'aluvial',
  3: 'erosion fluvial',
  4: 'rio'
    }
}

# Change the file path to a .yaml file within the directory
with open('/content/drive/MyDrive/ProyectoFin/Dst2_Segmentacion/Dst2_Segmentacion/data.yaml', 'w') as file:
    yaml.dump(data, file,
              default_flow_style=False,
              sort_keys=False)

!pip install ultralytics

from ultralytics import YOLO

# 1. Cargar el modelo (nano, el más pequeño)
model = YOLO("yolo11n-seg.pt")

# Afinar el modelo
results = model.train(data="/content/drive/MyDrive/ProyectoFin/Dst2_Segmentacion/Dst2_Segmentacion/data.yaml",
                      epochs=50, # Número de iteraciones
                      imgsz=640, # Tamaño de las imágenes (máxima dimensión)
                      plots=True, # Guardar gráficos de entrenamiento
                      )

from IPython.display import Image as IPyImage

IPyImage(filename='/content/runs/segment/train/results.png', width=1000)

model = YOLO('/content/runs/segment/train/weights/best.pt')

preds = model('/content/drive/MyDrive/ProyectoFin/Dst2_Segmentacion/Dst2_Segmentacion/images/test')

# Imágenes con buenas segmentaciones:
preds[0].show()

for i, pred in enumerate(preds):
    print(f"Mostrando imagen {i+1}")
    pred.show()

import cv2
import numpy as np
from ultralytics import YOLO
import os
import shutil

# Cargar tu modelo entrenado de YOLOv8
modelo = YOLO('/content/runs/segment/train/weights/best.pt')  # Cambia esta ruta por la de tu modelo entrenado

# Crear un directorio para guardar las máscaras
output_dir = '/content/drive/MyDrive/resultados_mask'
os.makedirs(output_dir, exist_ok=True)

# Función para borrar todas las máscaras existentes
def borrar_mascaras(output_dir):
    if os.path.exists(output_dir):
        shutil.rmtree(output_dir)
    os.makedirs(output_dir, exist_ok=True)

# Borrar las máscaras existentes antes de procesar nuevas imágenes
borrar_mascaras(output_dir)

# Cargar la imagen que deseas procesar
imagen_path = '/content/ej2.jpg'  # Cambia esto por el path de tu imagen
imagen = cv2.imread(imagen_path)

# Verificar si la imagen se cargó correctamente
if imagen is None:
    raise ValueError(f"No se pudo cargar la imagen en la ruta: {imagen_path}")

# Realizar la predicción
resultados = modelo(imagen)  # Predicciones de la imagen

# Índice de la clase "erosión fluvial" (cambia esto según tu modelo)
indice_erosion_fluvial = 3  # Asegúrate de que este índice sea correcto

# Procesar los resultados
for i, result in enumerate(resultados):
    if result.masks is not None:
        for idx, (mask, cls) in enumerate(zip(result.masks.data, result.boxes.cls)):  # Acceder a la data de la máscara y la clase
            if cls == indice_erosion_fluvial:
                print(f"Procesando máscara {i} - Segmento {idx}, forma: {mask.shape}")

                # Convertir tensor de PyTorch a NumPy
                mascara_np = mask.cpu().numpy().astype(np.uint8) * 255  # Escalar a 255

                # Asegurar que la máscara tenga 2D (remover dimensión extra si es necesario)
                if len(mascara_np.shape) == 3:
                    mascara_np = mascara_np[0]

                # Redimensionar la máscara al tamaño de la imagen original
                mascara_resized = cv2.resize(mascara_np, (imagen.shape[1], imagen.shape[0]))

                # Guardar la máscara
                mascara_filename = os.path.join(output_dir, f'mascara_erosion_fluvial_{i}_{idx}.png')
                cv2.imwrite(mascara_filename, mascara_resized)
                print(f'Máscara guardada en: {mascara_filename}')

import cv2
import numpy as np
import os

def calcular_area_mascara(mascara, resolucion_pixel=0.5):
    """
    Calcula el área de una máscara en píxeles y metros cuadrados.

    Args:
        mascara (np.array): Máscara binaria.
        resolucion_pixel (float, optional): Resolución del píxel en metros.
                                           Por defecto es 0.5 metros/píxel.

    Returns:
        tuple: Una tupla que contiene el área en píxeles y el área en metros cuadrados.
    """
    # Calcular el área en píxeles
    area_en_pixeles = np.sum(mascara == 255)

    # Calcular el área en metros cuadrados
    area_en_metros_cuadrados = area_en_pixeles * (resolucion_pixel ** 2)

    return area_en_pixeles, area_en_metros_cuadrados

# Directorio donde se guardan las máscaras
output_dir = '/content/drive/MyDrive/resultados_mask'

# Get dimensions of the first mask to initialize combined_mask
first_mask_path = next((os.path.join(output_dir, f) for f in os.listdir(output_dir) if f.endswith('.png')), None)
if first_mask_path:
    first_mask = cv2.imread(first_mask_path, cv2.IMREAD_GRAYSCALE)
    combined_mask = np.zeros_like(first_mask)
else:
    raise ValueError("No mask files found in the directory.")

# Procesar todas las máscaras en el directorio
for mascara_filename in os.listdir(output_dir):
    if mascara_filename.endswith('.png'):
        ruta_mascara = os.path.join(output_dir, mascara_filename)
        mascara = cv2.imread(ruta_mascara, cv2.IMREAD_GRAYSCALE)

        # Asegurar que la máscara sea binaria (0 o 255)
        _, mascara_binaria = cv2.threshold(mascara, 127, 255, cv2.THRESH_BINARY)

        # Resize the current mask to match the combined_mask shape
        mascara_binaria = cv2.resize(mascara_binaria, (combined_mask.shape[1], combined_mask.shape[0]))

        # Combinar la máscara actual con la máscara combinada
        combined_mask = cv2.bitwise_or(combined_mask, mascara_binaria)

# Calcular el área de la máscara combinada
total_area_pixeles, total_area_metros_cuadrados = calcular_area_mascara(combined_mask)

print(f"Área total de las máscaras en píxeles: {total_area_pixeles}")
print(f"Área total de las máscaras en metros cuadrados: {total_area_metros_cuadrados}")

# Guardar la máscara combinada
combined_mask_filename = os.path.join(output_dir, 'mascara_erosion_combinada.png')
cv2.imwrite(combined_mask_filename, combined_mask)
print(f'Máscara combinada guardada en: {combined_mask_filename}')

import shutil
from google.colab import files

# Especifica el nombre de la carpeta que quieres comprimir (por ejemplo, 'mi_carpeta')
carpeta = '/content/runs'  # Cambia esto por el path correcto de tu carpeta

# Comprime la carpeta en un archivo .zip
shutil.make_archive('/content/runs', 'zip', carpeta)

# Descarga el archivo comprimido
files.download('/content/runs.zip')

from google.colab import drive
drive.mount('/content/drive')

import torch

# Guardar el modelo en Google Drive
torch.save(modelo.state_dict(), '/content/drive/MyDrive/yolo11n_seg.pth')

# Cargar el modelo desde Google Drive
modelo.load_state_dict(torch.load('/content/drive/MyDrive/yolo11n_seg.pth'))
modelo.eval()